---
title: ReadMore
description: A component which displays a short introductory prompt followed by  a Read More... link to load additional content on demand.
tableOfContents: 
  minHeadingLevel: 2
  maxHeadingLevel: 4
---
		 
	{/* Introduction */}
Blog sites typically use a ReadMore control to display a short introductory prompt followed by  a Read More... link which loads the remaining post content on demand.
		 
## Example
		 
export const tw = {
		exampleContainer: 'not-content w-full pb-4 w-max-lg bg-gray-300 dark:bg-gray-800 rounded-xl my-6',
		exampleTitle:'text-center bg-gray-300 dark:bg-sky-900 text-gray-300 dark:text-zinc-200 font-semibold py-2 mb-4 rounded-t-xl',
		icon:'inline-block size-6',
		image: 'inline-block max-h-6',
		p: 'pb-3'	,
		intro: 'ml-2 mt-2 text-lg'
}
		 
<div id='ReadMore-example' class={tw.exampleContainer} >
<div id='ReadMore-title' class={tw.exampleTitle}>Sample ReadMore Control</div>


import ReadMoreItem_A from '../../../../components/ReadMoreItem_A.astro'

export const closeSiblings = true

export const hs =
 `on closeOtherReadMores
	 if ${closeSiblings} is true
		 set allReadMores to the children of me
		 set allButtons to <button/> in me
		 for button in allButtons
			if button is not detail.sender
				send closeUp to the button
			end -- for
	 end -- if closeSiblings
 end -- closeOtherReadMores
`


<ul class="mx-6" script={hs}>
	<ReadMoreItem_A id="0" path="../../../api/readmore" >
		<h3>Hypermedia</h3>
		<div class={tw.intro}>
			<h5>HTML as a response to API requests</h5>
			<h5>Why are most API calls returing JSON when the browser is optimized to process HTML?</h5>
		</div>
	</ReadMoreItem_A>
	<ReadMoreItem_A id="1" path="../../../api/readmore" >
		<h3>HTMX</h3>
		<div class={tw.intro}>
			<h5>Adding functionality to any HTML element</h5>
			<h5>Can any element issue requests and update the DOM?</h5>
		</div>
	</ReadMoreItem_A>
	<ReadMoreItem_A id="2" path="../../../api/readmore">
		<h3>Tailwind CSS</h3>
		<div class={tw.intro}>
			<h5>Respnsive, mobile first styling</h5>
			<h5>A defined set of utility classes makes it easier to prototype user interfaces.</h5>
		</div>
	</ReadMoreItem_A>
	<ReadMoreItem_A id="3" path="../../../api/readmore">
		<h3>HyperScript</h3>
		<div class={tw.intro}>
			<h5>New client side scripting language</h5>
			<h5>Add client side functionality with an easy to learn English-prose syntax patterned after Hypertalk</h5>
		</div>
	</ReadMoreItem_A>
	<ReadMoreItem_A id="4" path="../../../api/readmore">
		<h3>Astro</h3>
		<div class={tw.intro}>
			<h5>Fast, robust Vite-based build tool featuring static and server rendered pages</h5>
			<h5>Utilize an island architecture to selectively hydrate content on the client side.</h5>
		</div>
	</ReadMoreItem_A>

</ul>



</div>
	{/* Example Control in Action */}

		 
## Description
	{/* General Description */}

	A `ReadMore` control presents a short introductory text block followed by a clickable "Read More" link which reveals the remaining content in an expandable block below the introduciton.
	
	Blog sites are the most common patreons for `ReadMore` controls.   Multiple blog posts can be displayed on one page using ReadMore items.   Each post is introduced with an opening title sentence, often with the author, and posting date.   The remaining content is hidden from view until the user clicks the "Read More" link, at which point the content is revealed.

	The action of a ReadMore controls is very similar to an Accordion control.   The main difference is the button which reveals the hidden content is placed after the introductory text.   Also, an alternative caption is displayed when the content is revealed, for example 'Read Less...'.   A twirl icon offers further confirmation that the hidden content is now being displayed.

	ReadMore controls allow the developer to place multiple blog posts or other titles onto a page while conserving vertical real estate.   The users is still able to access the full text of each post or article by simple clicking.

	For this example, an Astro component named ReadMoreItem_A is utilized.    The introductory text is placed into the components default slot.   An `id` and `path` values are passed as props.  When the user clicks or hovers on the ReadMore text, the remaining content is lazy-loaded in to the body element of the component.   Then, a click event transitions the body elements height from 0 to a calculated height value over the specified duration.

	The basic source code to implement a ReadMore control is shown below.   The [code](#code) section below contains the props, scripts, styling and an Everything tab where you can copy/paste the example into your project.   You will need to set up the custom API routes and appropriate html responses to the fetch request, but the example code should help you get started.
	
	{/* Example  Code block showing the  control in action. */}


	```astro title="Read More Control Example" "{hs}" "ReadMoreItem_A"
---
const closeSiblings = true

const hs =
 `on closeOtherReadMores
	 if ${closeSiblings} is true
		 set allReadMores to the children of me
		 set allButtons to <button/> in me
		 for button in allButtons
			if button is not detail.sender
				send closeUp to the button
			end -- for
	 end -- if closeSiblings
 end -- closeOtherReadMores
`
---

<ul class="mx-6" script={hs}>
	<ReadMoreItem_A id="0" path="/api/readmore" >
		<h3>Hypermedia</h3>
		<div class={tw.intro}>
			<h5>HTML as a response to API requests</h5>
			<h5>Why are most API calls returing JSON when the browser is optimized to process HTML?</h5>
		</div>
	</ReadMoreItem_A>
	<ReadMoreItem_A id="1" path="/api/readmore" >
		<h3>HTMX</h3>
		<div class={tw.intro}>
			<h5>Adding functionality to any HTML element</h5>
			<h5>Can any element issue requests and update the DOM?</h5>
		</div>
	</ReadMoreItem_A>
	<ReadMoreItem_A id="2" path="/api/readmore">
		<h3>Tailwind CSS</h3>
		<div class={tw.intro}>
			<h5>Respnsive, mobile first styling</h5>
			<h5>A defined set of utility classes makes it easier to prototype user interfaces.</h5>
		</div>
	</ReadMoreItem_A>
	<ReadMoreItem_A id="3" path="/api/readmore">
		<h3>HyperScript</h3>
		<div class={tw.intro}>
			<h5>New client side scripting language</h5>
			<h5>Add client side functionality with an easy to learn English-prose syntax patterned after Hypertalk</h5>
		</div>
	</ReadMoreItem_A>
	<ReadMoreItem_A id="4" path="/api/readmore">
		<h3>Astro</h3>
		<div class={tw.intro}>
			<h5>Fast, robust Vite-based build tool featuring static and server rendered pages</h5>
			<h5>Utilize an island architecture to selectively hydrate content on the client side.</h5>
		</div>
	</ReadMoreItem_A>

</ul>

	```
## Features
		 
## Components
	{/* Breakdown of each Astro Components used for this control */}
## Props
	{/* Each component, with code block showing the props interface */}
## Styling
To improve readability, the Tailwind classes and Hyperscripts are both extracted from the markup and encapsulated into  Astro `tw` and `hs` local variables within the [Component Script](https://docs.astro.build/en/basics/astro-components/#the-component-script) which are then referenced in the html markup. 
		 
The advantage of this strategy is to allow long run-on strings to be formatted as concatenated, multi-line strings which aids readability and code maintenance.
		 
## Transitions
	{/* Description of the animations used in the control */}
## Slots
	{/* Outline the name/function of each slot */}
## Code
	{/* Brief explanation of the component */}
import {Tabs, TabItem } from '@astrojs/starlight/components'
		 
<Tabs>
	<TabItem label='Props'>
	```js
		const {id} = Astro.props 
	```
	</TabItem>
		 
	<TabItem label='HTML'>
	```html
		 
	<li id={id} class={tw.li}>
		<div>
			<slot/>
			<button class={tw.button} script='install readMore'>Read More &#11015;</button>
		</div>
		{/* Must leave this div empty, will be lazy loaded by the above fetch call*/}
		<div  class={tw.body} style="transition: all 250ms ease-out"></div>	
	</li>
	
	```
	</TabItem>
		 
	<TabItem label='Scripts'>
	```js

<script type="text/hyperscript">

	behavior readMore

		def calcHeight()
			set openHeight to 0
			set readMoreContent to the children of the next .body
			for item in readMoreContent 
				increment openHeight by the item's offsetHeight
			end -- for
			increment openHeight by 25  -- for bottom padding
			return openHeight 
		end 

	  on mouseenter from me
			get the innerHTML of the next .body
			if it is empty then 
				set path to '/api/history/' + @id of the closest <li/>
				fetch `${path}` as html then put it into the next .body
		end 

		on click from me
			add .bg-green-950 to me
			remove .bg-indigo-950 from me then settle then
			measure the next .body
			if the result.height is greater than 0 then send closeUp to me
			otherwise send openUp to me end
			remove .bg-green-950 from me
			add .bg-indigo-950 to me then settle
		end

		on openUp
			send closeOtherReadMores to closest parent <ul/>
			put "Read Less &#11014;" into me
			set newHeight to calcHeight()
			if newHeight is less than 500 then
				set the *height of the next .body to (newHeight + 'px') then settle
			otherwise
				set the *height of the next .body to 500 px then settle
			end -- if
		end

		on closeUp
			put "Read More &#11015;" into me
			set the *height of the next .body to 0 then settle
		end

</script>
	```
	</TabItem>
		 
	<TabItem label='Tailwind'>
	```js

export const tw = {
	li: 'mb-8 shadow-lg rounded-lg',
	body: 'body h-0 px-4 text-pretty text-gray-700 dark:text-zinc-200 dark:bg-slate-900 overflow-y-auto',
	button: 'block w-full mx-auto px-4 py-1 rounded-lg ' + 
	'text-sm font-fjalla text-end ' + 
	'text-gray-400 bg-indigo-950 opacity-50 hover:opacity-70 ' +
	'dark:text-zinc-200 dark:bg-sky-900 '
}
	```
	</TabItem>
		 
	<TabItem label='Everything'>
	```astro
	---
import {twMerge} from 'tailwind-merge'


const defaultOverscrollHeight = 400
const defaultDuration = 200

const {id} = Astro.props

export const tw = {
	li: 'mb-8 shadow-lg rounded-lg',
	body: 'body h-0 px-4 text-pretty text-gray-700 dark:text-zinc-200 dark:bg-slate-900 overflow-y-auto',
	button: 'block w-full mx-auto px-4 py-1 rounded-lg ' + 
	'text-sm font-fjalla text-end ' + 
	'text-gray-400 bg-indigo-950 opacity-50 hover:opacity-70 ' +
	'dark:text-zinc-200 dark:bg-sky-900 '
}

---


<script type="text/hyperscript">

	

	behavior readMore

		def calcHeight()
			set openHeight to 0
			set readMoreContent to the children of the next .body
			for item in readMoreContent 
				increment openHeight by the item's offsetHeight
			end -- for
			increment openHeight by 25  -- for bottom padding
			return openHeight 
		end 

	  on mouseenter from me
			get the innerHTML of the next .body
			if it is empty then 
				set path to '/api/history/' + @id of the closest <li/>
				fetch `${path}` as html then put it into the next .body
		end 

		on click from me
			add .bg-green-950 to me
			remove .bg-indigo-950 from me then settle then
			measure the next .body
			if the result.height is greater than 0 then send closeUp to me
			otherwise send openUp to me end
			remove .bg-green-950 from me
			add .bg-indigo-950 to me then settle
		end

		on openUp
			send closeOtherReadMores to closest parent <ul/>
			put "Read Less &#11014;" into me
			set newHeight to calcHeight()
			if newHeight is less than 500 then
				set the *height of the next .body to (newHeight + 'px') then settle
			otherwise
				set the *height of the next .body to 500 px then settle
			end -- if
		end

		on closeUp
			put "Read More &#11015;" into me
			set the *height of the next .body to 0 then settle
		end
</script>

	<li id={id} class={tw.li}>
		<div>
			<slot/>
			<button class={tw.button} script='install readMore'>Read More &#11015;</button>
		</div>
		{/* Must leave this div empty, will be lazy loaded by the above fetch call*/}
		<div  class={tw.body} style="transition: all 250ms ease-out"></div>	
	</li>
	```
	</TabItem>
</Tabs>
		 
##  Usage
	{/* Discuss use cases */}	
---
title: Highlight Active Search
description: Active Search with HTMX with Highlited Matches
tableOfContents: 
  minHeadingLevel: 2
  maxHeadingLevel: 5
---
		 
{/* Introduction */}
## Example

This hypcomponent is a prototype for [hypermedia exchange](https://htmx.org/essays/hypermedia-apis-vs-data-apis/) because it illustrates a front-end coupled to backend routes that respond to XHR requests by returning only html markup.

An active search `<input>` is shown  which is based on the [Active Search example from the htmx documentation](http://htmx.org/examples/active-search/).   However, this hyperComponent expands on that example by providing live hilighting of matched substrings.  In addition, the hilight color can be selected from a dropdown menu containing the full Tailwind color pallet.  Clicking a color from the pallet changes the highlight color.    Another dropdown menu provides options for changing the match criteria. 

All functionality is powered by [htmx](https://htmx.org) and [Hypersript](https://hyperscript.org).  There are no JavaScript imports or `<script>` tags at all in this component. 

 A mini-project is included below to illustrate how this hyperComponent works.   The  example project displays a table of famous speeches in the English language.  Clicking any table row loads the full speech transcript and then switches focus to the Search `<input>`.   Any substring entered into the  Search `<input>` is then matched against the full transcript using regular expressions.  
 
 Successful matches are  surrounded with `<mark`> tags styled with the user's choice of Tailwind bg-color-*. The server returns the full speech transcript as html annotated with `<mark>` elements.  The user's  experience is analagous to using a felt tipped highlight marker on a printed document.

Take a tour of the example project by clicking on a famous speech.  Click  the Reset button (or select another speech) to start over.

The subsequent discussions go into great etail about all the source code used to create this  hyperComponent.

import {tw as rowStyles} from '../../../../pages/api/speeches'
		 
export const tw = {
		exampleContainer: 'not-content',
		exampleTitle: 'text-center bg-gray-300 dark:bg-sky-900 text-gray-300 dark:text-zinc-200 font-semibold py-2 mb-4 rounded-t-xl',
		icon:'inline-block size-6',
		image: 'inline-block max-h-6',
		p: 'pb-3'	,
		introduction: {
		h3: 'text-center text-xl lg:text-2xl',
		h4: 'pt-8 pb-4 text-center text-lg lg:text-xl',
		p: 'text-center font-semibold'	
		},
		table:'mx-auto my-4 max-w-max',
		...rowStyles,
		searchExample:{
			container: 'not-content pt-12 flex flex-nowrap justify-between items-center gap-2',
			colorPallet: 'colorPallet size-12 rounded-2xl ' +
				'bg-sky-700  dark:bg-indigo-600 ',
			palletIcon: 'inline-block size-6' ,
			resetButton: 'px-4 py-3 cursor-pointer rounded-xl ' + 
				'text-lg text-zinc-50 dark:text-zinc-300 ' +
				'bg-sky-700  dark:bg-indigo-600',
		},
		speech:{
			wrapper: 'not-content w-full mx-auto max-h-[50rem] overflow-y-auto rounded-t-lg ' + 
				'bg-gray-100 dark:bg-gray-950',
			title: 'p-4 text-center text-balance text-xl ' + 
				'text-indigo-900 dark:text-amber-100/80 ' + 
				'border-b-2 border-gray-200 dark:border-gray-700 ',
			transcript: 'p-4'
		},
}

{/* Intro */}
<div id='highlight-search-example' class={tw.exampleContainer} >
<div id='highlight-search-title' class={tw.exampleTitle}>Sample Highlight Active Search Control</div>
<div id="introduction" class="w-10/12 mx-auto">
	<h3 class={tw.introduction.h3}>Famous Speeches in the English Language</h3>
	<h4 class={tw.introduction.h4}>Use the Search control below to highlight words from the most famous speeches that shaped  our world.</h4>
	<p class={tw.introduction.p}>Click to select any Speech from the list</p>
</div>
</div>

{/*  Table of Famous Speeches */}
<table class={tw.table}
				id="all-speeches"
				hx-trigger="load"  
				hx-get="/api/speeches/"
				hx-target="<tbody/>"
				hx-swap="innerHTML"
				script={hs.table}>
	<thead>
		<tr><th>Speaker</th><th>Title</th><th>Date</th></tr>
	</thead>
	<tbody></tbody>
</table>


		 


import Searchbox from '../../../../components/search/searchbox.astro'
import ClickDropdownMenu_A from '../../../../components/ClickDropdownMenu_A.astro'
import PalletGrid from '../../../../components/PalletGrid.astro'

export const defaultSpeechTitle = 'Click on the any of the famous orations listed above.'
export const defaultSpeechTranscript = 'The full transcript will be displayed here. Use the Search box to dynamnically highlight any part of the transcript'

export const hs = {
	resetButton:`
		on load
			put the "${defaultSpeechTitle}" into the #{'speech-title'} then
			put the "${defaultSpeechTranscript}" into the #{'speech-transcript'} then 
			send reset to the <table#all-speeches/> 
			send reset to the #{'searchbox'}
		end 
		
		on click 
			go to the #{'introduction'} smoothly
		end`,
	table: `								
		on reset
			remove .${tw.rowHilight} from <tr/>
		end `,
	colorPallet: `
		on click 
			-- cache the hilight color in a data-* attribute
			-- transmit the highlight color to the backend via a hidden <input/>
			set originalHilightColor to the @data-hilight-color of the #{'search-container'}
			remove .{originalHilightColor} from the #{'search-container'}
			set newHilightColor to my @bgColor
			add .{newHilightColor} to the #{'search-container'}
			set the @data-hilight-color of the #{'search-container'} to the newHilightColor
			set the value of the #{'hilight-color'} to the newHilightColor
			trigger update on the  #{'searchbox'}
		end
		`
}



{/*  Search Box Example*/}
<div class={tw.searchExample.container}>
	<Searchbox id="searchbox" 
		searchPath="/api/speeches/match/" 
		target="#speech-transcript" 
		swapStrategy="innerHTML"
		height="h-12"
	/>

	<ClickDropdownMenu_A id='colorpallet' 
		moveXY='-200,18'
		buttonStyles={tw.searchExample.colorPallet} 
		duration='180ms'>
	<img slot="leftIcon" src='/images/tailwind_icon.svg' 
		alt='tailwind icon' class={tw.searchExample.palletIcon}/>
	<PalletGrid orientation='vertical' hs={hs.colorPallet}/>
</ClickDropdownMenu_A>	 

	<button class={tw.searchExample.resetButton} 
		script={hs.resetButton}>Reset</button>
</div>


<div class={tw.speech.wrapper}>
	<h4 id="speech-title" class={tw.speech.title}></h4>
	<div id="speech-transcript" class={tw.speech.transcript}>
	</div>
</div>


		 
## Description
	{/* General Description */}
	{/* Example  Code block showing the  control in action. */}

[Hypermedia exchanges](https://htmx.org/essays/hypermedia-apis-vs-data-apis/) require that the backend return formatted, finished html.  Thus the developer must have control over the server's response.   The [Astro](https://astro.build) build tool is perfect for this because it is easy to create [custom API endpoints](https://docs.astro.build/en/guides/endpoints/).   In Astro, all that is needed is to place a .js file into the Pages folder.  In that file, you must export a GET, POST, PATCH or DELETE function and then Astro will build the correct route and respond to those AJAX requests.

The GET and POST requests in this example use data stored on disc (in JSON files), but does not return the raw data.  Instead, the data is used by the server  to format finished html fragments which are returned in the Response object.   HTMX attributes  specify how and where the returned markup is inserted into the DOM.  

Read through all the example code below to see how this was accomplished.


## Features

This Active Search with highlight hyperComponent will:

1.  Use Tailwind bg-color-* classes picked from a dropdown color pallet
2.  Match substrings entered into the `<input>` against a block of raw text
3.  Return html markup with `<mark>` tags surrounding any matched substring
4.  Allow optional restricted matching (case sensitive, whole word, or others)
5.  User selectable hilight color
6.  Smooth scrolling to the transcript and back to the search input
7.  Results are updated with keystrokes, pasteing text into the `<input`>, clearing the field, etc.
8.  Search `<input>` and dropdown menus are fully customizable using Tailwind utility classes
		 
## Components
	{/* Breakdown of each Astro Components used for this control */}
### Searchbox

There is a single main component which provides the GUI for active searching and highlighting. 

The code for the Searchbox.astro component is shown below.   In order for this component to function, backend code which responds to the htmx issued requests must also be provided, as presented in the next section. 

Also, the Searchbox component must point to a block of text in which to search for matches.

Dropdown menus within the Searchbox control are provided by using the [ClickDropdownMenu_A](/components/menus/click_a/) component.   The SearchOptions dropdown is indicated by a down-caret icon to the left of the search `<input>`.  Multiple `<li>` elements are passed into the default slot which constitute the options for modifying the RegEx match criteria used by the backend.    To provide the user's selection, a Hyperscript stores the textContent of the `<li>` into a hidden field.   HTMX includes this field in the request where the backend recieves and decodes the search options.

Another [ClickDropdownMenu_A](/components/menus/click_a/) instance is used to present a pallet of colors allowing the user to change the color of the highlighted matched substrings in the response.   A [PalletGrid](/components/menus/examples/pallet/#palletgrid) component is passed to the default slot of the [ClickDropdownMenu_A](/components/menus/click_a/).  This displays a grid of default Tailwind color variants and shades. A hyperscript is used to store the user's selection into the 'bgColor' attribute but also into another hidden `<input>` so the value can be transported to the backend when needed.

Examining the `html` tab below will reveal these hidden `<input>`s used to pass values to the backend in order to configure the response.

#### Props

```js
interface Props {
		id?:string  
		placeholder?:string  
		searchPath:string
		target:string 
		swapStrategy:string, 
		height?:string  
}
```

##### id

Each Searchbox component recieves a unique identifier as a prop.  This identifier is used by the Hyperscripts to perform certain updates and styling changes.

##### placeholder

This string is displayed in dimmed font to prompt the user to enter a substring into the `<input>`.  

##### target

This prop accepts a string value representing the DOM element where the response will be placed.   You should pass an htmx-compatible CSS selector here.   The actual value you pass will then be referenced by the htmx attribute `hx-target`.   The resulting html will be swapped into this DOM position according to the next prop which specifies the swap strategy.

##### swapStrategy

HTMX provides a liberal set of options for how the response markup is placed into the target.   In the example project a `<div>` is used to display the full speech transcript and thus is the natural target for the highlited version of the transcript.   The example replaces the `innerHTML` of the target when the highlighted version is returned.

##### height

This prop allows you to adjust the height of the control to meet the needs of your layout.  Any valid Tailwind height class will work.

There is no width prop.   To adjust the width, wrap the control in a container and size the container's width.

#### Slots

##### rightIcon

The magnifying glass icon to the right of the `<input>` in this example is actually the default content of the `rightIcon` slot.    Most search controls display a magnifying glass icon as a symbol of the control's function.   In this example, the icon is inert (does not respond to clicks).   

You may substitute another icon (or even another Dropdown menu) to replace the default magnifying glass by passing markup into the 	`rightIcon` slot

#### Events
#### Attributes

##### data-hilight-color

This attribute of the `<div id="search-container">` is assigned a default value from a local constant `defaultBackgroundColor`.   The example project uses `bg-yellow-200`. 

The value of this attribute is picked up by the Hyperscript code and used to dynamically change the background color of the entire component when the user picks a swatch from the color pallet dropdown.

In this manner the `data-hilight-color`  is used as a local cache for the Hyperscript.

#### Styling

For coding convenience all Tailwind classes are extracted into a local `tw` constant as discussed in the [Tailwind Issues](about/tailwind/) page.

#### Transitions

Smooth scrolling to and from the Search control is provided by Hyperscript.  Inspect the script code below to see how this is done.

#### Code
	
<Tabs>
	<TabItem label='Props'>
	```js

interface Props {
		id?:string  // a unique identifier
		placeholder?:string  //default placeholder text in the <input> field
		searchPath:string //api backend route for s
		target:string  //where the response will be placed
		swapStrategy:string,  //using this swap strategy
		height?:string  //optional classes for setting control height
}
 
const {
		id,
		placeholder = "Search for...",
		searchPath,
		target,
		swapStrategy,
		height = 'h-10'
} = Astro.props 
		 
	```
	</TabItem>
		 
	<TabItem label='HTML'>
	```html "input" "script" "data-hilight-color" "ClickDropdownMenu_A"

		<div id='search-container' 
		class={tw.container} 
		data-hilight-color=`${defaultBackgroundColors}`>
		{/* Search Options menu */}
		<ClickDropdownMenuA id="search-options-menu" 
			buttonStyles={tw.optionsMenu} 
			moveXY="-12,10" >
			  {/* Down Caret icon */}
			<svg slot="rightIcon" class={tw.icon}  fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
					<path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/>
				</svg>
				{/* Search Criteria options */}
				<li class={tw.menuItem} script={hs.menuItem}>Contains</li>
				<li class={tw.menuItem} script={hs.menuItem}>Whole Word</li>
				<li class={tw.menuItem} script={hs.menuItem}>Case Sensitive</li>
				<li class={tw.menuItem} script={hs.menuItem}>Case Insensitive</li>
				<li class={tw.menuItem} script={hs.menuItem}>Begins With</li>
				<li class={tw.menuItem} script={hs.menuItem}>Ends With</li>
		</ClickDropdownMenuA>
		{/* Hidden inputs ... values are transmitted to backend via hx-include 
		 Do Not Reorder These <input/> b/c the backend is referencing the values from an element array by index>*/}
		<input type="hidden" id="speech-index" name="speech-index" value=""/>
		<input type="hidden" id="search-options" name="search-options" value="Contains"/>
		<input type="hidden" id="hilight-color" name="hilight-color" value=`${defaultBackgroundColors}`/>
		{/* Search String Input field */}
		<input id=`${id}` name="search"
			type="search"
			class={tw.input}
			placeholder={placeholder}
			hx-post=`${searchPath}`
			hx-include="<input/>"
			hx-trigger="input changed delay:500ms, search, update"
			hx-target=`${target}`
			hx-swap=`${swapStrategy}`
			script={hs.searchInput}
			>
		</input>
		{/* Magnify Icon */}
		<slot name="rightIcon" >
			<svg 
					fill="currentColor" 
					class={tw.rightIcon}
					version="1.1" 
					id="Capa_1" 
					xmlns="http://www.w3.org/2000/svg" 
					xmlns:xlink="http://www.w3.org/1999/xlink" 
					viewBox="0 0 490.4 490.4" 
					xml:space="preserve">
						<g id="SVGRepo_bgCarrier" 
						stroke-width="0">
					</g>
					<g id="SVGRepo_tracerCarrier" 
					stroke-linecap="round" 
					stroke-linejoin="round">
				</g>
				<g id="SVGRepo_iconCarrier"> 
					<g> 
						<path d="M484.1,454.796l-110.5-110.6c29.8-36.3,47.6-82.8,47.6-133.4c0-116.3-94.3-210.6-210.6-210.6S0,94.496,0,210.796 s94.3,210.6,210.6,210.6c50.8,0,97.4-18,133.8-48l110.5,110.5c12.9,11.8,25,4.2,29.2,0C492.5,475.596,492.5,463.096,484.1,454.796z M41.1,210.796c0-93.6,75.9-169.5,169.5-169.5s169.6,75.9,169.6,169.5s-75.9,169.5-169.5,169.5S41.1,304.396,41.1,210.796z">
						</path> 
						</g> 
					</g>
				</svg>
		</slot>
	</div>

		 
	```
	</TabItem>
		 
	<TabItem label='Scripts'>
	```js
	const hs = {
		menuItem: `
			on click 
				send closeDropdown to the #{'search-options-menu'} then settle then 
				set the @title of the #{'search-options-menu'} to my textContent
				set the value of the #{'search-options'} to my textContent 
				trigger update on the <[name='search']/>
			end `,
		searchInput: `
			on reset 
				set my value to ''
				set the value of the #{'search-options'} to 'Contains'
				set the @title of the #{'search-options-menu'}  to 'Contains'
				set the value of the #{'speech-index'} to ''
				call me.focus()
			end
	`
} 
	```
	</TabItem>
		 
	<TabItem label='Tailwind'>
	```js
	const tw = {
	container: `flex-grow flex flex-nowrap items-center overflow-hidden justify-around rounded-2xl ` +
	  defaultBackgroundColors,
	input: `${height} px-4 w-full font-inherit focus:outline-none ` + 
		'font-bold text-lg ' + 
		'text-gray-900 dark:text-zinc-200 ' + 
		'bg-slate-200 dark:bg-slate-800 '+ 
		'placeholder-blue-800/30 dark:placeholder-cyan-600/50',
	icon:'inline-block size-6',
	leftIcon: '',
	rightIcon:'w-12 h-12 px-2 ' + defaultTextColors,
	optionsMenu: 'p-0 mx-2 mt-1 cursor-pointer focus:ring-0 ' + 
		'font-extrabold ' + defaultTextColors + " " +
		'bg-transparent hover:bg-transparent ' +
		'hover:text-slate-950 dark:hover:text-yellow-600',
  menuItem: 'px-4 hover:text-purple-600 hover:dark:text-sky-800 ' +
    'hover:bg-gray-200 hover:dark:bg-stone-300 ',
}
	```
	</TabItem>
		 
	<TabItem label='Everything'>
	```astro
	---
import ClickDropdownMenuA from '../ClickDropdownMenu_A.astro'
 
interface Props {
		id?:string  // a unique identifier
		placeholder?:string  //default placeholder text in the <input> field
		searchPath:string //api backend route for s
		target:string  //where the response will be placed
		swapStrategy:string,  //using this swap strategy
		height?:string  //optional classes for setting control height
}

{/* Common default styling for several elements */}
export const defaultTextColors = 'text-slate-600'
export const defaultBackgroundColors = 'bg-yellow-200'
 
const {
		id,
		placeholder = "Search for...",
		searchPath,
		target,
		swapStrategy,
		height = 'h-10'
} = Astro.props 

const tw = {
		container: `flex-grow flex flex-nowrap items-center overflow-hidden justify-around rounded-2xl ` +
			defaultBackgroundColors,
		input: `${height} px-4 w-full font-inherit focus:outline-none ` + 
			'font-bold text-lg ' + 
			'text-gray-900 dark:text-zinc-200 ' + 
			'bg-slate-200 dark:bg-slate-800 '+ 
			'placeholder-blue-800/30 dark:placeholder-cyan-600/50',
		icon:'inline-block size-6',
		leftIcon: '',
		rightIcon:'w-12 h-12 px-2 ' + defaultTextColors,
		optionsMenu: 'p-0 mx-2 mt-1 cursor-pointer focus:ring-0 ' + 
			'font-extrabold ' + defaultTextColors + " " +
			'bg-transparent hover:bg-transparent ' +
			'hover:text-slate-950 dark:hover:text-yellow-600',
		menuItem: 'px-4 hover:text-purple-600 hover:dark:text-sky-800 ' +
			'hover:bg-gray-200 hover:dark:bg-stone-300 ',
}
 
const hs = {
		menuItem: `
			on click 
				send closeDropdown to the #{'search-options-menu'} then settle then 
				set the @title of the #{'search-options-menu'} to my textContent
				set the value of the #{'search-options'} to my textContent 
				trigger update on the <[name='search']/>
			end `,
		searchInput: `
			on reset 
				set my value to ''
				set the value of the #{'search-options'} to 'Contains'
				set the @title of the #{'search-options-menu'}  to 'Contains'
				set the value of the #{'speech-index'} to ''
				call me.focus()
			end
	`
} 
 
---

	<div id='search-container' 
		class={tw.container} 
		data-hilight-color=`${defaultBackgroundColors}`>
		{/* Search Options menu */}
		<ClickDropdownMenuA id="search-options-menu" 
			buttonStyles={tw.optionsMenu} 
			moveXY="-12,10" >
			  {/* Down Caret icon */}
			<svg slot="rightIcon" class={tw.icon}  fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
					<path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/>
				</svg>
				{/* Search Criteria options */}
				<li class={tw.menuItem} script={hs.menuItem}>Contains</li>
				<li class={tw.menuItem} script={hs.menuItem}>Whole Word</li>
				<li class={tw.menuItem} script={hs.menuItem}>Case Sensitive</li>
				<li class={tw.menuItem} script={hs.menuItem}>Case Insensitive</li>
				<li class={tw.menuItem} script={hs.menuItem}>Begins With</li>
				<li class={tw.menuItem} script={hs.menuItem}>Ends With</li>
		</ClickDropdownMenuA>
		{/* Hidden inputs ... values are transmitted to backend via hx-include 
		 Do Not Reorder These <input/> b/c the backend is referencing the values from an element array by index>*/}
		<input type="hidden" id="speech-index" name="speech-index" value=""/>
		<input type="hidden" id="search-options" name="search-options" value="Contains"/>
		<input type="hidden" id="hilight-color" name="hilight-color" value=`${defaultBackgroundColors}`/>
		{/* Search String Input field */}
		<input id=`${id}` name="search"
			type="search"
			class={tw.input}
			placeholder={placeholder}
			hx-post=`${searchPath}`
			hx-include="<input/>"
			hx-trigger="input changed delay:500ms, search, update"
			hx-target=`${target}`
			hx-swap=`${swapStrategy}`
			script={hs.searchInput}
			>
		</input>
		{/* Magnify Icon */}
		<slot name="rightIcon" >
			<svg 
					fill="currentColor" 
					class={tw.rightIcon}
					version="1.1" 
					id="Capa_1" 
					xmlns="http://www.w3.org/2000/svg" 
					xmlns:xlink="http://www.w3.org/1999/xlink" 
					viewBox="0 0 490.4 490.4" 
					xml:space="preserve">
						<g id="SVGRepo_bgCarrier" 
						stroke-width="0">
					</g>
					<g id="SVGRepo_tracerCarrier" 
					stroke-linecap="round" 
					stroke-linejoin="round">
				</g>
				<g id="SVGRepo_iconCarrier"> 
					<g> 
						<path d="M484.1,454.796l-110.5-110.6c29.8-36.3,47.6-82.8,47.6-133.4c0-116.3-94.3-210.6-210.6-210.6S0,94.496,0,210.796 s94.3,210.6,210.6,210.6c50.8,0,97.4-18,133.8-48l110.5,110.5c12.9,11.8,25,4.2,29.2,0C492.5,475.596,492.5,463.096,484.1,454.796z M41.1,210.796c0-93.6,75.9-169.5,169.5-169.5s169.6,75.9,169.6,169.5s-75.9,169.5-169.5,169.5S41.1,304.396,41.1,210.796z">
						</path> 
						</g> 
					</g>
				</svg>
		</slot>
	</div>


		 
	```
	</TabItem>
</Tabs>
		 

#### API routes

All routing in Astro is file-based, including backend API routes.  

Here is the folder/file structure used for this mini-project.  

import { FileTree } from '@astrojs/starlight/components';

<FileTree>

- src
	- data
		- **famousSpeeches.json**
	- pages
		- api
			- search
				- **[id].js**
				- **index.js**
				- **match.js**

</FileTree>

The Tab panel below is displays the entire source code for each backend route.

##### famousSpeaches.json

The `famousSpeeches.json` file contains the raw data for each Speech.  There is too much text to show all the data here so just one sample Speech object is included in the TabPanel below to illustrate the shape of the data.  All other Famous Speech entries use the same object structure.

In a real world application, the data used will likely be stored in a database somewhere.   If you use this hyperComponent, you will need to adjust the data source and provide the appropriate async lookup functions in the next three  Javascript files.

##### [id].js

The `[id].js` route decodes the index of the speech from `params.id` value of the [Context](https://docs.astro.build/en/reference/api-reference/#endpoint-context) object provided as an argument to the GET function by Astro.   Also the `transcript=true` field is decoded from  the `url.searchParams`.  Using this information, the raw text of an individual speech is pulled from the appropriate array index in the `famousSpeeches.json` file.  

The Response object then returns an html fragment containing the entire speech transcript with `<p>` tags swapped for line breaks.

##### index.js

A list of speeches is loaded into the `<table>` of the project example using the `index.js` route.  The raw data is looped using a .map() function returning a single `<tr>` containing the speakers name, title of the speech, and the date.   

Notice that a Hyperscript is also added to each `<tr>` so that a click on the row loads the transcript of the speech into a target `<div>`.

##### match.js

This route receives `search`, `speech-index`,  `search-criteria`, and `hilight-color`  values sent by the request issued from the path injected into the hx-post attribute of the Search component.  Here is the shape of the data received by this route:

```js title="request.text()"
search=xyz&speech-index=15&search-criteria=Contains&hilight-color=bg-yellow-200
```

In Astro you get access to these values by calling `.text()` function  on the request object which was destructured from the [Context](https://docs.astro.build/en/reference/api-reference/#endpoint-context) object.

This yields an array of values which are then split and processed into local variables. 

The `search` field of the request contains the substring which the user wishes to test against the speech transcript.

The `speech-index` field is the array index for the data in `famousSpeeches.json`

The `search-criteria` is  a filter to be applied to the regular expression, such as 'Whole Word' or 'Case Sensitive', etc.  The value of this field is set by the user choosing  an option from the dropdown at the left of the search `<input>`.

The `hilight-color` is transmitted to the backend from a value cached in the `data-hilight-color` attribute of  the `div#search-container` and specifies a background color for all the `<mark>` tags in the final response.

The remaining code in `match.js` uses a regular expression to match substrings in the speech transcript and then bracket the matches with `<mark>` tags containing the specfied Tailwind class in the `highlight-color`.

The resulting html markup is returned to the caller via the Response object where the hx-swap attribute is set to replace the innerHTML of the speech transcript `<div>`.




import {Tabs, TabItem } from '@astrojs/starlight/components'


<Tabs>
	<TabItem label='[id].js'>
	```js
	import famousSpeeches from '../../../data/famousSpeeches.json?json'

export const tw = {
	p: 'pb-6 text-md lg:text-lg text-gray-800 dark:text-neutral-100 '
}

const speechInfo = (speech) => {
 return  speech.title + ' by ' + speech.speaker + ' on ' + speech.date
}

export function swapLineEndings(text) {
	//add a beginning and ending <p> tag
	let markup = `<p class="${tw.p}">` + text + '</p>'
	//then replace all \\n with <p> tags with appropriate styling
	markup = markup.replace(/\\n/g, `</p><p class="${tw.p}">`);
	return markup;
}

//GET
export async function GET({ params, url }) {
	const speechID = parseInt(params.id)
	const speech = famousSpeeches[speechID]
	if (!speech) {
	    return new Response ('Speech not found')
	}
	//What is being requested?
	const searchParams = url.searchParams;
	const transcriptOnly = searchParams.get('transcript') === 'true';
	if (transcriptOnly) {
		return new Response(swapLineEndings(speech.transcript), {status: 200})
	}
	else {
		return new Response (speechInfo(speech), {status: 200})
	}

}

	```
	</TabItem>

	<TabItem label='index.js'>
	```js
	import { twMerge } from 'tailwind-merge';
import famousSpeeches from '../../../data/famousSpeeches.json?json'

export const tw = {
	tr: 'cursor-pointer font-semibold ' + 
	'even:hover:bg-amber-300/50 odd:hover:bg-amber-400/30 ' + 
	'even:hover:text-blue-800 odd:hover:text-blue-800 ' +
	'even:hover:dark:bg-indigo-950/60 odd:hover:dark:bg-indigo-950 ' + 
	'even:hover:dark:text-amber-400 odd:hover:dark:text-amber-400',
	rowHilight: 'text-orange-500'
}

const getSpeechData = () => {

 const markup = famousSpeeches.map((speech)=>{
		return  `
		<tr 
			index="${speech.id}" 
			class="${tw.tr}" 
			script="
				on click 
					fetch /api/speeches/${speech.id} as text then 
					put it into the #{'speech-title'}
					fetch /api/speeches/${speech.id}?transcript=true as html then 
					put it into the #{'speech-transcript'}
					set the value of the #{'speech-index'} to the ${speech.id}
					remove .${tw.rowHilight} from <tr/> 
					add .${tw.rowHilight} to me
					go to the  #{'searchbox'} smoothly then settle then 
					call #{'searchbox'}.focus()
				end

				"
		>	
		<td>${speech.speaker}</td>
		<td>${speech.title}</td>
		<td>${speech.date}</td>
	</tr>
	`
 })

 return markup.join('\n')

}

export const GET = async ({params, request}) => {
	return new Response (getSpeechData(), {status: 200})
	
	
}


	```
	</TabItem>
		 
	<TabItem label='match.js'>
	```js
	import famousSpeeches from '../../../data/famousSpeeches.json?json'
import {swapLineEndings, tw as baseStyles} from './[id]'
import {defaultBackgroundColors} from '../../../components/search/searchbox.astro'

let hilightColor = defaultBackgroundColors

const tw = {
	...baseStyles,
}

function markupSpeech(speech, searchString, searchCriteria) {
	if (searchString === '') {
		return swapLineEndings(speech.transcript)
	}
   
	let regex = '\\b' + searchString + '\\w*\\b'
	let modifiers = 'g'

	switch (searchCriteria) {
		case 'case-sensitive' :
			modifiers = 'g'	
			break
		case 'case-insensitive' :
			modifiers = 'gi'
			break
		case 'whole-word' :
			regex = '\\b' + searchString + '\\b'
			break
		case 'begins-with' :
			regex = '\\b' + searchString + '\\w*\\b'
			break
		case 'ends-with' :
			regex = '\\b\\w*' + searchString + '\\b'
			break
		case 'contains':
			regex = searchString
			break
	}

	/* Use regex to find matches which are then wrapped with <mark> tags including
     a Tailwind class for the hilight color 		*/
	const searchRegex = new RegExp(regex, modifiers)
  let markup = speech.transcript
	markup = markup.replace(searchRegex, `<mark class="${hilightColor}">$&</mark>`);
	markup = swapLineEndings(markup)
	return markup
}

export const POST = async ({request}) => {
    // Extract data from the request.text()
		//data = data search=xyz&speech-index=15&search-criteria=Contains&hilight-color=bg-yellow-200
    const data = await request.text()
		// console.log(`data`, data)
		const searchString = decodeURIComponent(data.split('&')[0].split('=')[1])
		const speechId = parseInt(data.split('&')[1].split('=')[1])
		const searchCriteria = decodeURIComponent(data.split('&')[2].split('=')[1])
			.toLowerCase()
			.replace(' ', '-')
		hilightColor = data.split('&')[3].split('=')[1]
		// console.log(`searchString`, searchString)
		// console.log(`searchCriteria`, searchCriteria)
		// console.log(`hilightColor`, hilightColor)

		//now get the transcript
		const speech = famousSpeeches[speechId]
		if (!speech) {
				return new Response ('Speech not found')
		}
  
	return new Response(markupSpeech(speech, searchString, searchCriteria), {status: 200});
}


		 
	```
	</TabItem>
		 

		 
	<TabItem label='famousSpeeches.json'>
	```json
	[ ... 
	{
			"id": 14,
			"speaker": "Lou Gehrig",
			"title": "Luckiest Man",
			"date": "July 4, 1939",
			"transcript":"Fans, for the past two weeks you have been reading about a bad break I got.\\nYet today I consider myself the luckiest man on the face of the earth.\\nI have been in ballparks for seventeen years and have never received anything but kindness and encouragement from you fans. Look at these grand men. Which of you wouldn’t consider it the highlight of his career just to associate with them for even one day?\\nSure I’m lucky.\\nWho wouldn’t consider it an honor to have known Jacob Ruppert? Also, the builder of baseball’s greatest empire, Ed Barrow? To have spent six years with that wonderful little fellow, Miller Huggins? Then to have spent the next nine years with that outstanding leader, that smart student of psychology, the best manager in baseball today, Joe McCarthy?\\nSure I’m lucky.\\nWhen the New York Giants, a team you would give your right arm to beat, and vice versa, sends you a gift - that’s something. When everybody down to the groundskeepers and those boys in white coats remember you with trophies -- that’s something.\\nWhen you have a wonderful mother-in-law who takes sides with you in squabbles with her own daughter -- that’s something.\\nWhen you have a father and a mother who work all their lives so you can have an education and build your body -- it’s a blessing.\\nWhen you have a wife who has been a tower of strength and shown more courage than you dreamed existed -- that’s the finest I know.\\nSo, I close in saying that I might have been given a bad break, but I've got an awful lot to live for."
		},
	]

	```
	</TabItem>
	
</Tabs>
		 



## Code
	{/* Brief explanation of the component */}
All of the source code for the Searchbox component is listed below.  

To use this component in your project, just copy and paste the contents of the Everything tab.
		 
<Tabs>
	<TabItem label='Props'>
	```js
		 
	```
	</TabItem>
		 
	<TabItem label='HTML'>
	```html
		 
	```
	</TabItem>
		 
	<TabItem label='Scripts'>
	```js
	```
	</TabItem>
		 
	<TabItem label='Tailwind'>
	```js
	```
	</TabItem>
		 
	<TabItem label='Everything'>
	```astro
		 
	```
	</TabItem>
</Tabs>
		 
##  Usage
	{/* Discuss use cases */}